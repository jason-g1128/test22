<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>My New Hugo Site</title>
    <link>https://jason-g1128.github.io/</link>
    <description>Recent content on My New Hugo Site</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Mon, 13 Jul 2020 16:25:30 +0800</lastBuildDate>
    
	<atom:link href="https://jason-g1128.github.io/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Spring Cloud 0基础教程</title>
      <link>https://jason-g1128.github.io/post/about/</link>
      <pubDate>Mon, 13 Jul 2020 16:25:30 +0800</pubDate>
      
      <guid>https://jason-g1128.github.io/post/about/</guid>
      <description>0.学习目标  了解系统架构的演变 了解RPC与Http的区别 掌握HttpClient的简单使用 知道什么是SpringCloud 独立搭建Eureka注册中心 独立配置Robbin负载均衡  1.系统架构演变 随着互联网的发展，网站应用的规模不断扩大。需求的激增，带来的是技术上的压力。系统架构也因此也不断的演进、升级、迭代。从单一应用，到垂直拆分，到分布式服务，到SOA，以及现在火热的微服务架构，还有在Google带领下来势汹涌的Service Mesh。我们到底是该乘坐微服务的船只驶向远方，还是偏安一隅得过且过？
其实生活不止眼前的苟且，还有诗和远方。所以我们今天就回顾历史，看一看系统架构演变的历程；把握现在，学习现在最火的技术架构；展望未来，争取成为一名优秀的Java工程师。
1.1. 集中式架构 当网站流量很小时，只需一个应用，将所有功能都部署在一起，以减少部署节点和成本。此时，用于简化增删改查工作量的数据访问框架(ORM)是影响项目开发的关键。
存在的问题：
 代码耦合，开发维护困难 无法针对不同模块进行针对性优化 无法水平扩展 单点容错率低，并发能力差  1.2.垂直拆分 当访问量逐渐增大，单一应用无法满足需求，此时为了应对更高的并发和业务需求，我们根据业务功能对系统进行拆分：
优点：
 系统拆分实现了流量分担，解决了并发问题 可以针对不同模块进行优化 方便水平扩展，负载均衡，容错率提高  缺点：
 系统间相互独立，会有很多重复开发工作，影响开发效率  1.3.分布式服务 当垂直应用越来越多，应用之间交互不可避免，将核心业务抽取出来，作为独立的服务，逐渐形成稳定的服务中心，使前端应用能更快速的响应多变的市场需求。此时，用于提高业务复用及整合的分布式调用是关键。
优点：
 将基础服务进行了抽取，系统间相互调用，提高了代码复用和开发效率  缺点：
 系统间耦合度变高，调用关系错综复杂，难以维护  1.4.服务治理（SOA） 当服务越来越多，容量的评估，小服务资源的浪费等问题逐渐显现，此时需增加一个调度中心基于访问压力实时管理集群容量，提高集群利用率。此时，用于提高机器利用率的资源调度和治理中心(SOA)是关键
以前出现了什么问题？
 服务越来越多，需要管理每个服务的地址 调用关系错综复杂，难以理清依赖关系 服务过多，服务状态难以管理，无法根据服务情况动态管理  服务治理要做什么？
 服务注册中心，实现服务自动注册和发现，无需人为记录服务地址 服务自动订阅，服务列表自动推送，服务调用透明化，无需关心依赖关系 动态监控服务状态监控报告，人为控制服务状态  缺点：
 服务间会有依赖关系，一旦某个环节出错会影响较大 服务关系复杂，运维、测试部署困难，不符合DevOps思想  1.5.微服务 前面说的SOA，英文翻译过来是面向服务。微服务，似乎也是服务，都是对系统进行拆分。因此两者非常容易混淆，但其实缺有一些差别：
微服务的特点：
 单一职责：微服务中每一个服务都对应唯一的业务能力，做到单一职责 微：微服务的服务拆分粒度很小，例如一个用户管理就可以作为一个服务。每个服务虽小，但“五脏俱全”。 面向服务：面向服务是说每个服务都要对外暴露服务接口API。并不关心服务的技术实现，做到与平台和语言无关，也不限定用什么技术实现，只要提供Rest的接口即可。 自治：自治是说服务间互相独立，互不干扰  团队独立：每个服务都是一个独立的开发团队，人数不能过多。 技术独立：因为是面向服务，提供Rest接口，使用什么技术没有别人干涉 前后端分离：采用前后端分离开发，提供统一Rest接口，后端不用再为PC、移动段开发不同接口 数据库分离：每个服务都使用自己的数据源 部署独立，服务间虽然有调用，但要做到服务重启不影响其它服务。有利于持续集成和持续交付。每个服务都是独立的组件，可复用，可替换，降低耦合，易维护    微服务结构图：</description>
    </item>
    
    <item>
      <title>线程</title>
      <link>https://jason-g1128.github.io/post/blog/</link>
      <pubDate>Sun, 12 Jul 2020 13:44:11 +0800</pubDate>
      
      <guid>https://jason-g1128.github.io/post/blog/</guid>
      <description>线程 主要内容  线程基础 线程池  教学目标 -[ ] 能够理解线程概念
-[ ] 学会使用线程的创建方式
-[ ] 能够理解线程的状态
-[ ] 能够理解线程通信概念
-[ ] 能够理解等待唤醒机制
-[ ] 能够描述Java中线程池运行原理
第一章 线程基础 1.1 线程简介 概念: 现代操作系统在运行一个程序时，会为其创建一个进程。例如，启动一个Java程序，操作系统就会创建一个Java进程。现代操作系统调度的最小单元是线程，也叫轻量级进程（LightWeight Process），在一个进程里可以创建多个线程，这些线程都拥有各自的计数器、堆栈和局部变量等属性，并且能够访问共享的内存变量。处理器在这些线程上高速切换，让使用者感觉到这些线程在同时执行。
Java线程的实现方式：
Java线程使用操作系统的内核线程实现，内核线程（Kernel-Level Thread, KLT）是直接由操作系统内核（Kernel，内核）支持的线程，这种线程由内核来完成线程切换，内核通过操纵调度器（Scheduler）对线程进行调度，并负责将线程的任务映射到各个处理器上。每个内核线程可以视为内核的一个分身（孙悟空的分身术），这样操作系统就有能力同时处理多件事情，支持多线程的内核就叫做多线程内核（Muti-Threads Kernel)。
Java程序如何使用内核线程：
程序一般通过使用内核线程的高级接口&amp;mdash;&amp;ndash;轻量级进程（Light Weight Process, LWP），也就是我们通常意义上的线程。每个LWP都由一个内核线程支持。也就是说任何时候使用Java代码创建线程，调用Thread.start()的时候，都是通过LWP接口创建了KLT内核线程，然后通过OS的Thread Scheduler对内核线程进行调度分配CPU。线程模型如下图所示：
内核线程的优点：
（1）每一个内核线程都是独立的轻量级进程，一个线程的阻塞不会影响整个进程的工作。
内核线程的缺点：
（1）由于是基于内核线程实现，各种线程的操作，如创建、析构、中断、休眠和同步，都需要系统调度（频繁从用户态切换进内核态），而系统调度的代价相对较高；
（2）占用内核资源，同时轻量级进程的数量有限。
主内存与工作内存：
JAVA内存模型规定了所有的变量都存储在主内存（Main Memory）中。所有的线程都有自己的工作内存，工作内存中保存了被该线程使用到的变量的主内存副本拷贝，线程对变量的所有操作（读取、赋值）都必须在工作内存中执行，而不能直接读写主内存中的变量。同时，线程之间也无法读写对方的工作内存。关系图： 1.2 实现线程的方式 1.2.1 Runnable接口 一个接口，定义了一个run()方法，重写run()实现线程的主体逻辑
1.2.2 Thread类 Java中线程的抽象，将继承Runnable类的对象放入Thread中，Thread中定义很多控制管理线程的方法
为什么通常创建线程使用Runnable? 第一点：结构简单，层次分明，Runnable中只有一个run(),实现线程的主体逻辑只需要在run()中实现即可 第二点：不占用java单一继承的名额,在实现Runnable接口的同时还能继承其他的类 1.2.2.1 Thread类的常用方法   setName()/getName() 设置/获取线程名称
由于在一个进程中可能有多个线程，而多线程的运行状态又是不确定的，即不知道在多线程中当前执行的线程是哪个线程，所以在多线程操作中需要有一个明确的标识符标识出当前线程对象的信息，这个信息往往通过线程的名称来描述.当然也可以通过Thread的构造函数来设置public Thread(Runnable target,String name)</description>
    </item>
    
  </channel>
</rss>